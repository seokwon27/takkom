# 따꼼 ![logo](https://github.com/user-attachments/assets/88499428-0a72-49c2-949b-e03e25b65cb7)
<br /><br /><br />
![takkom](https://github.com/user-attachments/assets/f5b9493d-41c2-48fd-87f8-9187a15378bc)
![takkom2](https://github.com/user-attachments/assets/e95eb4bc-4fd5-47e1-848f-2afaef677a19)
![takkom3](https://github.com/user-attachments/assets/fe1193e3-e2d4-4b1d-bcbc-836a3b8dacc9)
<br /><br /><br />
## 🔗 배포 링크
https://takkom.vercel.app/
<br /><br /><br />


## 📖 목차

1. [프로젝트 소개](#프로젝트-소개)
2. [팀 소개](#팀-소개)
3. [주요 기능](#주요-기능)
4. [개발 기간](#개발-기간)
5. [기술 스택](#기술-스택)
6. [디자인 컨셉](#디자인-컨셉)
7. [서비스 구조](#서비스-구조)
8. [와이어프레임](#와이어프레임)
9. [API 명세서](#API-명세서)
10. [기능 설명](#기능-설명)
11. [자랑하고 싶은 코드](#자랑하고-싶은-코드)
12. [Trouble Shooting](#trouble-shooting)
13. [프로젝트 소감](#프로젝트-소감)
    <br /><br /><br />

## 프로젝트 소개

프로젝트 "따꼼"은 어린이 필수 예방접종 정보를 제공하고, 체크리스트와 캘린더를 통해 예방접종 진행 상황을 확인할 수 있는 웹 플랫폼을 만드는 프로젝트로, 예방접종 관련 데이터를 질병 관리청의 API를 통해 제공받아 사용자들에게 편리한 기능을 제공합니다.
<br /><br /><br />

## 팀 소개

<table>
   <tr>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Designer</b></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/seokwon27"><img width="100" alt="seokwon" src="https://github.com/user-attachments/assets/70bd7e8f-021b-432a-8310-bff7066db027"></a></td>
    <td align="center"><a href="https://github.com/joycie416"><img width="94" alt="joycie" src="https://github.com/user-attachments/assets/d1e52540-25ae-45f7-b5b5-7aeab9c8794a"></a></td>
    <td align="center"><a href="https://github.com/sehee-jang"><img width="94" alt="Sehee" src="https://github.com/user-attachments/assets/56a2db4b-a48d-4e70-b405-4e4446b45088"></a></td>
    <td align="center"><a href="https://github.com/stopbrother"><img width="94" alt="stopbrother" src="https://github.com/user-attachments/assets/8c216ea7-e0a9-43c6-9364-21655f788d35"></a></td>
    <td align="center"><a href="https://github.com/leeyeram84"><img width="94" alt="leeyeram" src="https://github.com/user-attachments/assets/d3f0a712-d114-47cc-af95-544fae26ad1e"></a></td>
     <td align="center"><a href=""><img width="94" alt="dori" src="https://github.com/user-attachments/assets/a38a9406-ec71-4e71-9565-1730ff2a1ceb"></a></td>
  </tr>
  <tr>
    <td align="center"><b><a href="https://github.com/seokwon27">이석원</a></b></td>
    <td align="center"><b><a href="https://github.com/joycie416">조해인</a></b></td>
    <td align="center"><b><a href="https://github.com/sehee-jang">장세희</a></b></td>
    <td align="center"><b><a href="https://github.com/stopbrother">정지형</a></b></td>
    <td align="center"><b><a href="https://github.com/leeyeram84">이예람</a></b></td>
    <td align="center"><b><a href="https://blog.naver.com/dori_320">전수빈</a></b></td>
  </tr>
</table>
<br /><br /><br />

## 주요 기능

- 연령별 예방 접종 정보 제공
- 예방 접종 가능한 병원 검색
- 등록된 아이 접종 일정 정보 및 접종 체크리스트 제공
- 로그인 시 아이 정보 저장 가능
  <br /><br /><br />

## 개발 기간

- **10/18 ~ 10/25**: 주제 및 기획 선정 완료
- **10/28 ~ 11/04**: UI 컴포넌트의 기본 기능 개발
- **11/04 ~ 11/07**: MVP 기능 구현 완료 및 배포
- **11/08 ~ 11/15**: UT 테스트 기반 기능 개선 및 버그 수정 (예정)
- **11/18 ~ 11/21**: 최종 발표회 (예정)
  <br /><br /><br />

## 기술 스택

### 프론트엔드 프레임워크/라이브러리

<div>
  <img src="https://img.shields.io/badge/Next-black?style=for-the-badge&logo=next.js&logoColor=white">
  <img src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=react&logoColor=white">
  <img src="https://img.shields.io/badge/TypeScript-007ACC?style=for-the-badge&logo=typescript&logoColor=white">
</div>

### 상태 관리

<div>
  <img src="https://img.shields.io/badge/TanStack%20Query-0078D7?style=for-the-badge&logo=react-query&logoColor=white">
  <img src="https://img.shields.io/badge/Zustand-2E7D32?style=for-the-badge&logo=zustand&logoColor=white">
</div>

### 데이터베이스 및 백엔드

<div>
  <img src="https://img.shields.io/badge/Supabase-3ECF8E?style=for-the-badge&logo=supabase&logoColor=white">
</div>

### UI 및 스타일링

<div>
  <img src="https://img.shields.io/badge/shadcn%2Fui-000?logo=shadcnui&logoColor=fff&style=for-the-badge">
  <img src="https://img.shields.io/badge/tailwindcss-%2338B2AC.svg?style=for-the-badge&logo=tailwind-css&logoColor=white">
  <img src="https://img.shields.io/badge/lucide--react-FF5555?style=for-the-badge&logo=lucide&logoColor=white">
</div>

### 폼 및 데이터 유효성 검증

<div>
  <img src="https://img.shields.io/badge/React%20Form-61DAFB?style=for-the-badge&logo=react&logoColor=white">
  <img src="https://img.shields.io/badge/Zod-2D3748?style=for-the-badge&logo=typescript&logoColor=white">
</div>

### PWA

<div>
  <img src="https://img.shields.io/badge/PWA-FFD700?style=for-the-badge&logo=progressive-web-apps&logoColor=black">
</div>

### 도구

<div>
  <img src="https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white">
  <img src="https://img.shields.io/badge/Github-181717?style=for-the-badge&logo=Github&logoColor=white">
  <img src="https://img.shields.io/badge/Figma-F24E1E?style=for-the-badge&logo=Figma&logoColor=white">
</div>

### 기타 유틸리티

<div>
  <img src="https://img.shields.io/badge/fast--xml--parser-4F46B8?style=for-the-badge&logo=xml&logoColor=white">
  <img src="https://img.shields.io/badge/date--fns-5A67D8?style=for-the-badge&logo=javascript&logoColor=white">
</div>
<br /><br /><br />

## 디자인 컨셉

아기에게 필요한 예방접종 정보를 알려주는 서비스인 만큼 어린아이의 눈높이에 맞는 컨셉을 가지려 했습니다.

- 서비스명 '따꼼' : 어린아이에게 '아프다'라는 말 대신 '아야'하는거야 라고 말해주듯, 주사를 아이의 관점으로 '따꼼' 하는 것에서 착안해 서비스명을 '따꼼'으로 지었습니다.
- 마스코트 '따꼬미' : 주사를 맞으면 머리가 쭈뼛서고, 따끔한 것을 이미지화 하여 표현하였습니다.
- 직관적이고 심플한 UI : 생소할 수 있는 접종명, 백신명 등을 이해하기 쉽게 표시하고, 전반적인 서비스 이용이 어렵지 않도록 구성하였습니다.
<br /><br /><br />

## 서비스 구조

- 메인 페이지
  - 연령별 접종 정보 페이지, 병원 찾기 페이지, 맞춤 예방점종 플랜 페이지 이동
  - 각종 이벤트 소개
- 연령별 예방접종 정보 페이지
  - 연령 선택
  - 연령에 따른 예방접종 필터
  - 해당 예방접종이 가능한 병원 검색
- 동네 병원 찾기 페이지
  - 병원 목록 불러오기
  - 병원 검색결과 필터
- 우리 아이 맞춤형 플랜 페이지
  - 사용자의 아이 기본 정보 등록 (이름, 생년월일, 특이사항, 아이 프로필 이미지)
  - 사용자의 아이 접종 내역 등록
  - 등록된 아이의 정보 수정
  - 등록된 정보를 바탕으로 맞춤형 접종 일정 월별 제공
  - 전체 접종 체크 리스트 확인 가능 (접종 기록 추가/삭제 가능)
- 회원가입/로그인 페이지
  - 인증/인가를 통한 회원가입 및 로그인 기능
  - 로그인 및 회원가입 시 유효성 검사
  - 소셜 로그인/회원가입 가능
- 마이페이지
  - 사용자 정보 확인
  - 로그아웃
    <br/><br/><br/>

## 와이어프레임
![1 홈페이지](https://github.com/user-attachments/assets/45258cdf-67b7-40c0-a2b2-db37bcf37213)
![2 접종 리스트](https://github.com/user-attachments/assets/38f38ade-805c-4098-a39c-08f789bcad3c)
![2 페이지 이동](https://github.com/user-attachments/assets/36640b0f-b22f-4106-8ecb-fcb0eb459585)
![3 병원검색페이지](https://github.com/user-attachments/assets/819e6b5b-c9d1-426a-b926-004fd667f9bc)
<br/><br/><br/>

## API 명세서

(추후에 ... )
<br/><br/><br/>

## 기능 설명

### [연령별 예방접종 정보]

1. 연령별 예방 접종 정보 필터 가능
   <br>- 대분류: 전체, 신생아, 영아기, 유아기, 아동기
   <br>- 중분류: 개월수, 나이
2. 해당 예방접종이 가능한 병원을 모달창을 통해 검색 후 병원찾기 페이지로 이동

### [동네 병원 찾기]

1. 시도(필수), 시군구(필수), 주소(선택), 병원명(선택) 입력 후 검색 가능

2. 특정 백신을 접종하는 병원을 찾을 수 있도록 백신 필터 기능 제공

3. 병원 정보 제공(주소, 전화번호, 접종 목록)

### [우리아이 맞춤형 플랜]

1. 사용자의 아이 등록 1단계: 이름(필수), 생년월일(필수), 특이사항(선택), 프로필 이미지(선택)
2. 사용자의 아이 등록 2단계: 접종 체크리스트를 통해 이미 맞은 접종을 체크
3. 아이 정보 등록/수정 기능
4. 접종 일정표를 통해 월별 접종 일정 확인

### [로그인/회원가입]

1. 일반 로그인: 아이디, 비밀번호
2. 소셜 로그인: 구글, 카카오톡
3. 인증/인가 및 유효성 검사

### [마이페이지]

1. 유저 정보 확인
2. 로그아웃 기능
   <br/><br/><br/>

## 자랑하고 싶은 코드

### [연령별 예방 접종 정보]

- 데이터 필터링을 위한 분류별 연결을 위한 전역상태관리
- 대분류에 따른 소분류 변동과 병명 초기화 작동

  ```tsx
  // 연령별 예방 접종 데이터 필터링
  // 'ageGroup'을 기준으로 'subAgeGroup'과 'selectedAge'를 업데이트하고,
  // 'currentDisease'는 초기화합니다.
  setAgeGroup: (newText: string) =>
      set(() => {
        return {
          ageGroup: newText,
          subAgeGroup: subGroup[newText],   // 대분류에 따른 소분류 데이터 설정
          selectedAge: subGroup[newText][0], // 첫 번째 연령 선택
          currentDisease: "" // 병명 초기화
        };
      }),

  const subGroup: { [key: string]: number[] } = {
    전체: [1000],
    신생아: [0, 0.4],
    영아기: [1, 2, 4, 6],
    유아기: [12, 15, 18, 19, 24, 48],
    아동기: [72, 132, 144]
  };
  ```

- 성능 향상을 위한 메모이제이션 적용
- 의존성 배열 설정을 통해 불필요한 리렌더링을 방지해보고자 함

  ```tsx
  // 선택된 연령에 따라 데이터 필터링
  const filteredData = useMemo(() => {
    if (!allData) return [];
    return selectedAge === 1000
      ? allData
      : allData.filter((item) => JSON.parse(item.vaccinate_date || "[]").includes(selectedAge));
  }, [allData, selectedAge]);

  // 총 페이지 수 계산
  const totalPages = Math.ceil(filteredData.length / ITEMS_PER_PAGE);

  // 현재 페이지에 해당하는 데이터 계산
  const currentPageData = useMemo(() => {
    const startIndex = (page - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return filteredData.slice(startIndex, endIndex);
  }, [filteredData, page]);

  // 페이지가 유효 범위를 벗어나면 첫 페이지로 리셋
  useMemo(() => {
    if (page > totalPages) {
      setPage(1);
    }
  }, [totalPages, page]);
  ```

### [동네 병원 찾기]

- '어린이 국가예방접종 지원사업 위탁의료기관 현황 정보' api를 사용하여 해당 지원사업을 진행중인 병원 정보를 가져왔습니다. 공공데이터로 api 구조를 원하는대로 바꿀 수 없어 지원하는 기능을 사용하여 모든 병원 정보를 불러온 후 추가로 필터링을 거쳐 데이터를 나열했습니다.

- 아래 코드는 첫 100개의 데이터를 불러와 추가 데이터가 있는지 확인한 후 `Promise.all`을 사용해 남은 데이터를 불러와 합쳐주는 코드입니다. Api에서 '시도, 시군구', '시도, 시군구, 주소' 또는 '시도, 시군구, 병원명' 검색까지만 지원해, 저희가 제공하려는 서비스보다 기능이 부족해 위 과정을 거치게 되었습니다. 이후 `useQuery` 커스텀 훅을 통해 데이터를 캐싱하여 불필요한 요청을 하지 않도록 했습니다. 자주 변동되는 데이터는 아니지만 업데이트 될 수 있으므로 1시간마다 `revalidate`하도록 했습니다.

  ```tsx
  // 병원 목록 가져오기
  export const getHospitals = async (
    input: HospitalParams
  ): Promise<HospitalData> => {
    const params = { serviceKey, ...input, numOfRows: "100", pageNo: "1" };
    const searchParams = new URLSearchParams(params).toString();
    const res = await fetch(BASE_URL + `/getOrgList3?` + searchParams, {
      method: "GET",
      next: {
        revalidate: 60 * 60
      }
    });

    ...

    if (body.maxPage > 1) {
      const allData = await Promise.all(
        Array(body.maxPage - 1)
          .fill(0)
          .map(async (_, idx) => {
            params.pageNo = String(idx + 2);
            const searchParams = new URLSearchParams(params).toString();

            const res = await fetch(BASE_URL + `/getOrgList3?` + searchParams, {...});
            ...
          })
      );
      for (const data of allData) {
        item = item.concat(data);
      }
    }

    return { items: item, totalCount: body.totalCount, maxPage: Math.ceil(body.totalCount / NUM_OF_CARDS_PER_PAGE) };
  };
  ```

### [우리 아이 맞춤형 플랜]

1. Custom Hooks 활용 (useChildrenQuery, useUserQuery)

   - useChildrenQuery, useUserQuery라는 custom hooks으로 분리하여 코드의 재사용성을 높이고, 각 데이터 fetch 로직을 더 직관적으로 만들었습니다. 이 방식은 코드의 유지보수를 쉽게 하고, 추후 다른 페이지에서도 재사용 가능이 가능합니다. Custom hook을 통한 코드 분리는 다른 개발자들이 코드를 빠르게 이해할 수 있게 하며, 이로 인해 협업에서도 유리한 점이 많습니다.

2. 자녀 정보 입력과 유효성 검사 (RegisterStep1)

   - formSchema는 zod를 사용하여 이름과 생년월일을 필수로 설정하며, 추가로 메모와 프로필 이미지는 선택 사항입니다.
   - useForm에서 zodResolver를 사용해 쉽게 유효성 검사를 설정하고, form.handleSubmit을 통해 제출 시 검사를 실행합니다.

   ```tsx
   import { useForm } from "react-hook-form";
   import { z } from "zod";
   import { zodResolver } from "@hookform/resolvers/zod";

   export const formSchema = z.object({
     name: z.string().min(1, { message: "이름은 필수입니다." }),
     birth: z.string().min(1, { message: "생년월일은 필수입니다." }),
     notes: z.string().optional(),
     profileImage: z.instanceof(File).optional()
   });

   const RegisterStep1 = ({ onNext, childInfo }) => {
     const form = useForm<z.infer<typeof formSchema>>({
       resolver: zodResolver(formSchema),
       defaultValues: {
         name: childInfo.name ?? "",
         birth: childInfo.birth ?? "",
         notes: childInfo.notes ?? ""
       }
     });

     const handleFormSubmit = async (data) => {
       onNext(data);
     };

     return (
       <Form {...form}>
         <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8 w-full">
           {/* 프로필 이미지 입력 필드 */}
           <FormField
             control={form.control}
             name="profileImage"
             render={() => (
               <FormItem>
                 <FormLabel>프로필 이미지</FormLabel>
                 <FormControl>
                   <Input
                     type="file"
                     accept="image/*"
                     onChange={(e) => setSelectedImage(e.target.files?.[0] ?? undefined)}
                   />
                 </FormControl>
                 <FormMessage />
               </FormItem>
             )}
           />

           {/* 이름 입력 필드 */}
           <FormField
             control={form.control}
             name="name"
             render={({ field }) => (
               <FormItem>
                 <FormLabel>이름</FormLabel>
                 <FormControl>
                   <Input placeholder="ex. 김따꼼" {...field} className="w-full" />
                 </FormControl>
                 <FormMessage />
               </FormItem>
             )}
           />
           {/* 다음 버튼 */}
           <Button type="submit">다음</Button>
         </form>
       </Form>
     );
   };
   ```

3. 접종 체크리스트: 데이터 그룹화

- Map 자료구조를 통하여 데이터를 백신이름과 질병별로 그룹화
- 중복되는 백신이름을 통합하여 각 백신의 질병이름과 접종차수, id, 추가정보를 담고 있는 객체 배열로 반환

  ```tsx
  export const groupVaccines = (vaccines: Vaccine[]) => {
    const vaccineMap = new Map<string, Map<string, { turns: number[]; ids: string[]; additions: boolean[] }>>();
    vaccines.forEach((vaccine) => {
      const { disease_name, vaccine_turn, id, vaccine_name, additional } = vaccine;
      if (!disease_name || !vaccine_turn || !vaccine_name) return;
      if (!vaccineMap.has(vaccine_name)) {
        vaccineMap.set(vaccine_name, new Map());
      }
      const diseaseMap = vaccineMap.get(vaccine_name);
      if (!diseaseMap?.has(disease_name)) {
        diseaseMap?.set(disease_name, { turns: [], ids: [], additions: [] });
      }
      diseaseMap?.get(disease_name)?.turns.push(vaccine_turn);
      diseaseMap?.get(disease_name)?.ids.push(id);
      diseaseMap?.get(disease_name)?.additions.push(additional);
    });
    const vaccinesArray = Array.from(vaccineMap.entries()).map(([vaccineName, diseaseMap]) => ({
      vaccineName,
      disease: Array.from(diseaseMap.entries()).map(([diseaseName, data]) => ({
        diseaseName,
        turns: data.turns,
        ids: data.ids,
        additions: data.additions
      }))
    }));
    return vaccinesArray;
  };
  ```

4. 접종 일정표

   - supabase에 저장한 접종 일정표를 기준으로 아이 생일에 맞는 접종 일정표를 제공합니다. 접종이 완료된 경우 목록에서 제거되며 선택, 해당 백신을 접종해야 하는 날짜와 추가/필수 접종 여부를 제공합니다.

   - 접종 일정표를 계산하는 핵심 로직은 다음과 같습니다. 각 접종 일정에 포함된 달에 해당 접종 일정을 저장해 월별 접종 일정표를 반환해줍니다. `date-fns` 라이브러리를 사용하여 날짜 계산을 효율적으로 처리할 수 있었습니다.

   ```tsx
   // 생일에 따라 접종 일정 계산하기
   export const calculateSchedule = (
     date?: string,
     schedules?: Tables<"vaccine">[]
   ): Map<string, vaccineSchedule[]> | null => {
     if (!date || !schedules) {
       return null;
     }
     const birthday = new Date(date);
     const mySchedule = new Map();
     // 접종일정표 상 가장 나중 일정의 마지막 일자
     const lastMonth = addDays(addMonths(addMonths(birthday, 12 * 12), 12), -1);

     // 비어 있는 달이 존재할 수 이어서 key를 먼저 생성
     let currentDate = birthday;
     while (isBefore(currentDate, lastMonth) || isEqual(addDays(currentDate, -1), lastMonth)) {
       mySchedule.set(format(currentDate, "yyyy.MM"), []);
       currentDate = addMonths(currentDate, 1);
     }

     for (const schedule of schedules) {
       const { id, vaccine_name, disease_name, vaccinate_date, duration, additional, vaccine_turn } = schedule;
       const [after, unit] = duration.split(" ");
       const startDate = addMonths(birthday, vaccinate_date);
       const startDateFormatted = format(startDate, "yyyy.MM.dd");

       if (unit === "일") {
         // 일 단위
         const startDate = addMonths(birthday, vaccinate_date);
         const startDateFormatted = format(startDate, "yyyy.MM.dd");
         const startMonthFormatted = format(startDate, "yyyy.MM");
         mySchedule.set(
           startMonthFormatted,
           mySchedule.get(startMonthFormatted).concat([...])
         );
       } else {
         // 개월 단위
         const endDate = addDays(addMonths(addMonths(birthday, vaccinate_date), Number(after)), -1);
         const endDateFormatted = format(endDate, "yyyy.MM.dd");

         // 위에서 key를 생성한 로직과 동일
         // 일정이 시작하는 달부터 끝나는 달까지 해당 접종 일정을 추가함
         let currentDate = startDate;
         while (isBefore(currentDate, endDate) || isEqual(addDays(currentDate, -1), endDate)) {
           const currentMonthFormatted = format(currentDate, "yyyy.MM");
           mySchedule.set(
             currentMonthFormatted,
             mySchedule.get(currentMonthFormatted).concat([...])
           );
           currentDate = addMonths(currentDate, 1);
         }
       }
     }

     return mySchedule;
   };
   ```

### [회원가입-유효성검사]

- zod를 이용해 복잡한 schema를 설정하였고, superRefine 매서드를 이용해 강력한 유효성 검사를 시도한 부분입니다.
- superRefine 매서드의 첫 번째 인자는 콜백함수가, 두 번째 인자에는 이슈를 생성하는 ctx가 들어갑니다. 이때, ctx에는 기존에 zod에서 제공하는 이슈도 있지만, 개발자가 직접 커스텀 할 수 있는 기능이 있어 해당 기능을 사용해 우리에게 맞는 이슈를 생성하였습니다.

  ```tsx
  const schema = z
    .object({
      email: z
        .string()
        .min(5, { message: "5글자 이상 입력해주세요." })
        .max(30, { message: "30글자 이하로 입력해주세요." }),
      password: z
        .string()
        .min(8, { message: "8글자 이상 입력해주세요." })
        .max(16, { message: "16글자 이하로 입력해주세요." }),
      passwordCheck: z
        .string()
        .min(8, { message: "8글자 이상 입력해주세요." })
        .max(16, { message: "16글자 이하로 입력해주세요." }),
      name: z.string().min(1, { message: "이름을 입력해주세요." })
    })
    .superRefine(({ password, passwordCheck }, ctx) => {
      // 비밀번호 재확인 체크
      if (password !== passwordCheck) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "비밀번호가 일치하지 않습니다.",
          path: ["passwordCheck"]
        });
      }
    });
  ```

  <br /><br /><br />

## Trouble Shooting

### 1. 접종 정보 페이지: 페이지네이션

- 문제: 페이지네이션 적용한 정보 리스트에서 필터링 적용 시 최초 전체 로딩에서 설정된 페이지에 데이터가 고정되는 현상
- 문제 원인: 데이터 fetch시 supabase의 count를 통해 totalPage를 설정하면서 데이터 자체에 페이지가 적용되었으나, 데이터를 가져온 후 client에서 상태를 통한 필터링으로 생기는 문제
- 해결방법: client에서 데이터를 가공하여 출력하기 때문에 페이지네이션 또한 페이지 상태를 추가하여 가공한 데이터를 기반으로 작동하도록 수정함.

### 2. 동네 병원 찾기

- 문제상황: 검색창과 페이지네이션에 사용할 state를 너무 많이 설정해, React에서 오류가 발생
- 해결방법: 검색창에 입력된 정보를 모두 하나의 state로 합치고, 페이지네이션에 필요한 정보는 쿼리스트링으로 넘기게 되었습니다.
- 이전에는 `brtcCd`, `sggCd`, `addr`, `org`에 대한 state가 별도로 존재하지만 아래 처럼 `params`라는 이름의 state로 합쳤습니다.

  ```tsx
  const SearchForm = (...) => {
    ...
    const searchParams = useSearchParams();
    const [params, setParams] = useState<{ brtcCd: string; sggCd: string; addr: string; org: string }>({
      brtcCd: searchParams.get("brtcCd") ?? BRTC,
      sggCd: searchParams.get("sggCd") ?? SGG,
      addr: searchParams.get("addr") ?? "",
      org: searchParams.get("org") ?? ""
    });
    const [disease, setDisease] = useState(searchParams.get("disease") || DISEASE);
    const [showInfoTag, setShowInfoTag] = useState(true);

    return (
      ...
    )
  };
  ```

- 페이지내이션은 상위컴포넌트에서 `currentPage`와 `startNum`을 저장해 state를 prop으로 넘겨주었지만, 데이터를 불러오는 과정과 렌더링되는 과정에서 오류와 경고가 발생해 쿼리스트링으로 불러오게 되었습니다. 쿼리 스트링을 사용하니 한층 더 간결하게 페이지네이션을 구현할 수 있었습니다.

  ```tsx
  // 상위 컴포넌트
  const HospitalList = () => {
    const searchParams = useSearchParams();
    const [brtcCd, sggCd, addr, org, disease, currentPage] = [
      searchParams.get("brtcCd") ?? "",
      searchParams.get("sggCd") ?? "",
      searchParams.get("addr") ?? "",
      searchParams.get("org") ?? "",
      searchParams.get("disease") ?? "",
      Number(searchParams.get("pageNo")) ?? 1
    ];

    ...

    return (
      ...
          <HospitalPagination
            maxPage={hospitalData.maxPage}
            currentPage={currentPage}
            params={{ brtcCd, sggCd, addr, org, disease }}
          />
      ...
    );
  };

  export default HospitalList;

  // 페이지네이션 컴포넌트
  const HospitalPagination = ({
    maxPage,
    currentPage,
    params
  }: {
    maxPage: number;
    currentPage: number;
    params: { brtcCd: string; sggCd: string; addr: string; org: string; disease?: string };
  }) => {
    const pathname = usePathname();

    let startNum = 1;
    if (maxPage >= 5) {
      if (currentPage - 2 >= 1 && currentPage + 2 < maxPage) {
        startNum = currentPage - 2;
      } else if (currentPage + 2 >= maxPage) {
        startNum = maxPage - 4;
      }
    }
    if (currentPage - 2 < 1) {
      startNum = 1;
    }

    return (
      ...
    )
  };
  ```

### 3. 복잡한 라벨 로직을 컴포넌트 분리로 개선

- 문제 상황

  - 복잡한 라벨 표시 로직: VaccineRecordList 컴포넌트에서 각 질병의 diseaseName 앞에 라벨("선택" 또는 "필수")을 표시해야 했는데, 이는 diseaseName의 additions 값에 따라 결정됨
  - additions 값이 모두 true면 "선택", 하나라도 false면 "필수"로 라벨을 표시해야 함
  - 가독성 저하: VaccineRecordList 내에서 라벨 로직이 직접 작성되어 코드가 복잡하고 가독성이 떨어짐

  ```tsx
  {data?.map(({ vaccineName, disease }) =>
            disease.map(({ diseaseName, ids, additions }) => {
              const isRequiredNot = additions.every((addition) => addition);
              const label = isRequiredNot ? "선택" : "필수";
              return (
                <li key={vaccineName}>
                  <div>{diseaseName}</div>
                  <div>{vaccineName}</div>
                ...
  ```

- 해결 방법

  - VaccineLabel 컴포넌트 분리:

    - additions 값을 받아서 "선택" 또는 "필수" 라벨을 반환하는 VaccineLabel 컴포넌트를 생성.
    - additions 배열이 전부 true면 "선택", 그렇지 않으면 "필수"로 표시하도록 구현.

  - VaccineRecordList 내 로직 단순화:
    - VaccineLabel 컴포넌트를 사용하여 라벨 로직을 간결하게 분리, VaccineRecordList 컴포넌트의 가독성을 개선함.

  ```tsx
  const VaccineLabel = ({ additions }: { additions: boolean[] }) => {
    const isRequiredNot = additions.every((addition) => addition);
    if (isRequiredNot) return <div>선택</div>
    if (!isRequiredNot) return <div>필수</div>
  };
  ...
  {data?.map(({ vaccineName, disease }) =>
      disease.map(({ diseaseName, ids, additions }) => (
          <li key={vaccineName}>
              <VaccineLabel additions={additions} />
              <div>{diseaseName}</div>
              <div>{vaccineName}</div>
              ...
  ```

### 4. 아이정보 UID 전달을 위한 데이터 삽입 및 조회 로직 수정

- 문제 상황

  - UID 없음: 1단계에서 등록된 아이가 없기 때문에 uid 값이 존재하지 않음.
  - UID 전달 필요: 아이 정보 입력 후 '다음' 버튼을 클릭하면 child 테이블에 기본 정보가 입력되고, 이때 UID가 자동 생성됨. 이 UID를 2단계로 전달해야 함.

- 해결 방법

  - insert 메소드의 인자를 배열에서 객체로 수정.
  - .single() 앞에 .select()를 추가하여 삽입된 데이터를 바로 조회할 수 있게 수정.

  ```tsx
  const { data: childData, error } = await supabase
    .from("child")
    .insert({
      user_id: user.id,
      name: name,
      birth: birthday,
      profile: profileImageUrl,
      notes: notes ?? ""
    })
    .select() //  이 부분 추가
    .single();
  ```

### 5. 이전 단계로 돌아갈 때 작성된 Form 데이터를 유지가 안됨

- 문제 상황
  - 이전 단계 데이터 유실: 이전 버튼을 통해 1단계로 돌아가면 이전에 입력한 Form 데이터가 불러와지지 않음.
  - 데이터는 이미 저장됨: supabase의 child 테이블에는 데이터가 저장된 상태이나, UI에서 다시 돌아갔을 때 저장된 정보가 표시되지 않음.
- 해결 방법

  - RegisterForm에서 childInfo 상태 생성

    - RegisterForm 컴포넌트에서 childInfo를 상태로 생성하여, 기본값으로 빈 객체({})로 초기화
    - childInfo를 RegisterStep1에 props로 전달하여, 이전 단계에서 입력한 정보가 유지되도록 함

  - RegisterStep1에서 childInfo 활용 - RegisterStep1 컴포넌트에서 전달받은 childInfo의 데이터를 Form의 defaultValues로 설정하여, 초기 값으로 사용. - 이렇게 설정하면 이전 버튼을 통해 돌아올 때 이전에 입력한 정보가 자동으로 입력란에 표시됨.

        ```tsx
        // RegisterForm 수정
        const RegisterForm: React.FC<ChildCardProps> = ({ userId }) => {
          const [childInfo, setChildInfo] = useState<Partial<Child>>({});

          return (
            <RegisterStep1
              onNext={handleNext}
              userId={userId}
              childInfo={childInfo}
            />
          );
        };
        ```

        ```tsx
        // RegisterStep1 수정
        const RegisterStep1 = ({ onNext, userId, childInfo }: RegisterStep1Props) => {
          const form = useForm({
            resolver: zodResolver(formSchema),
            defaultValues: {
              name: childInfo.name || "",
              birth: childInfo.birth || "",
              notes: childInfo.notes || ""
            }
          });

          return (
            <div>
              {/* JSX 코드 */}
            </div>
          );
        };
        ```

### 6. 소셜 로그인 리다이렉트 오류

- 문제 상황
  - 소셜 로그인 기능을 구현하는 과정에서, 사용자가 소셜 로그인 후 다시 페이지로 돌아올 때 리다이렉트 설정이 제대로 되어있지 않아 오류가 발생
  - 리다이렉트 URL 설정을 redirectTo를 통해 하였으나, 배포 환경에서는 각 환경에 맞는 리다이렉트 URL이 제대로 설정되지 않아 문제가 발생
- 해결 방법
  - 리다이렉트 URL 설정: redirectTo를 사용하여 로그인 후 리다이렉트할 URL을 설정
  - 환경 변수 사용: 배포 환경에서 리다이렉트 URL을 환경 변수로 설정하여 NEXT_PUBLIC_GOOGLE_REDIRECT_URL 값을 통해 vercel과 supabase에서 각 환경에 맞는 리다이렉트 URL을 자동으로 설정

  ```tsx
  const googleSignIn = async () => {
    const { error } = await browserClient.auth.signInWithOAuth({
      provider: "google",
      options: {
        queryParams: {
          access_type: "offline",
          prompt: "consent"
        },
        redirectTo: process.env.NEXT_PUBLIC_GOOGLE_REDIRECT_URL // 환경
      }
    });

    if (error) console.log("로그인 실패 : ", error);
  };
  ```
<br /><br /><br />

## 프로젝트 소감
<img width="691" alt="Screenshot 2024-11-06 at 8 31 36 PM" src="https://github.com/user-attachments/assets/86d45e55-5e9a-479a-a77d-49a9724a0e62">

