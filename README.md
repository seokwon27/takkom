# 따꼼 ![logo](https://github.com/user-attachments/assets/88499428-0a72-49c2-949b-e03e25b65cb7)

<br /><br /><br />
![takkom](https://github.com/user-attachments/assets/f5b9493d-41c2-48fd-87f8-9187a15378bc)
![takkom2](https://github.com/user-attachments/assets/e95eb4bc-4fd5-47e1-848f-2afaef677a19)
![takkom3](https://github.com/user-attachments/assets/fe1193e3-e2d4-4b1d-bcbc-836a3b8dacc9)
<br /><br /><br />

## 🔗 배포 링크

https://takkom.vercel.app/
<br /><br /><br />

## 📖 목차

1. [프로젝트 소개](#프로젝트-소개)
2. [팀 소개](#팀-소개)
3. [주요 기능](#주요-기능)
4. [개발 기간](#개발-기간)
5. [기술 스택](#기술-스택)
6. [디자인 컨셉](#디자인-컨셉)
7. [서비스 구조](#서비스-구조)
8. [와이어프레임](#와이어프레임)
9. [API 명세서](#API-명세서)
10. [기능 설명](#기능-설명)
11. [Trouble Shooting](#trouble-shooting)
12. [자랑하고 싶은 코드](#자랑하고-싶은-코드)
13. [프로젝트 소감](#프로젝트-소감)
    <br /><br /><br />

## 프로젝트 소개

프로젝트 "따꼼"은 어린이 필수 예방접종 정보를 제공하고, 체크리스트와 캘린더를 통해 예방접종 진행 상황을 확인할 수 있는 웹 플랫폼을 만드는 프로젝트로, 예방접종 관련 데이터를 질병 관리청의 API를 통해 제공받아 사용자들에게 편리한 기능을 제공합니다.
<br /><br /><br />

## 팀 소개

<table>
   <tr>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Frontend</b></td>
    <td align="center"><b>Designer</b></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/seokwon27"><img width="100" alt="seokwon" src="https://github.com/user-attachments/assets/70bd7e8f-021b-432a-8310-bff7066db027"></a></td>
    <td align="center"><a href="https://github.com/joycie416"><img width="94" alt="joycie" src="https://github.com/user-attachments/assets/d1e52540-25ae-45f7-b5b5-7aeab9c8794a"></a></td>
    <td align="center"><a href="https://github.com/sehee-jang"><img width="94" alt="Sehee" src="https://github.com/user-attachments/assets/56a2db4b-a48d-4e70-b405-4e4446b45088"></a></td>
    <td align="center"><a href="https://github.com/stopbrother"><img width="94" alt="stopbrother" src="https://github.com/user-attachments/assets/8c216ea7-e0a9-43c6-9364-21655f788d35"></a></td>
    <td align="center"><a href="https://github.com/leeyeram84"><img width="94" alt="leeyeram" src="https://github.com/user-attachments/assets/d3f0a712-d114-47cc-af95-544fae26ad1e"></a></td>
     <td align="center"><a href="https://blog.naver.com/dori_320"><img width="94" alt="dori" src="https://github.com/user-attachments/assets/a38a9406-ec71-4e71-9565-1730ff2a1ceb"></a></td>
  </tr>
  <tr>
    <td align="center"><b><a href="https://github.com/seokwon27">이석원</a></b></td>
    <td align="center"><b><a href="https://github.com/joycie416">조해인</a></b></td>
    <td align="center"><b><a href="https://github.com/sehee-jang">장세희</a></b></td>
    <td align="center"><b><a href="https://github.com/stopbrother">정지형</a></b></td>
    <td align="center"><b><a href="https://github.com/leeyeram84">이예람</a></b></td>
    <td align="center"><b><a href="https://blog.naver.com/dori_320">전수빈</a></b></td>
  </tr>
</table>

- **이석원**: 연령별 예방접종 정보 페이지
- **조해인**: 동네 병원 찾기 페이지
- **장세희**: 우리 아이 맞춤형 페이지: 아이 등록/수정하기
- **정지형**: 우리 아이 맞춤형 페이지: 우리아이 접종 내역
- **이예람**: 회원가입, 일반로그인, 소셜로그인
- **전수빈**: 와이어프레임, UI 디자인, 로고
  <br /><br /><br />

## 주요 기능

- 연령별 예방 접종 정보 제공
- 예방 접종 가능한 병원 검색
- 등록된 아이 접종 일정 정보 및 접종 체크리스트 제공
- 로그인 시 아이 정보 저장 가능
  <br /><br /><br />

## 개발 기간

- **10/18 ~ 10/25**: 주제 및 기획 선정 완료
- **10/28 ~ 11/04**: UI 컴포넌트의 기본 기능 개발
- **11/04 ~ 11/07**: MVP 기능 구현 완료 및 배포
- **11/08 ~ 11/15**: UT 테스트 기반 기능 개선 및 버그 수정 (예정)
- **11/18 ~ 11/21**: 최종 발표회 (예정)
  <br /><br /><br />

## 기술 스택

### 프론트엔드 프레임워크/라이브러리

<div>
  <img src="https://img.shields.io/badge/Next-black?style=for-the-badge&logo=next.js&logoColor=white">
  <img src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=react&logoColor=white">
  <img src="https://img.shields.io/badge/TypeScript-007ACC?style=for-the-badge&logo=typescript&logoColor=white">
</div>

### 상태 관리

<div>
  <img src="https://img.shields.io/badge/TanStack%20Query-0078D7?style=for-the-badge&logo=react-query&logoColor=white">
  <img src="https://img.shields.io/badge/Zustand-2E7D32?style=for-the-badge&logo=zustand&logoColor=white">
</div>

### 데이터베이스 및 백엔드

<div>
  <img src="https://img.shields.io/badge/Supabase-3ECF8E?style=for-the-badge&logo=supabase&logoColor=white">
</div>

### UI 및 스타일링

<div>
  <img src="https://img.shields.io/badge/shadcn%2Fui-000?logo=shadcnui&logoColor=fff&style=for-the-badge">
  <img src="https://img.shields.io/badge/tailwindcss-%2338B2AC.svg?style=for-the-badge&logo=tailwind-css&logoColor=white">
  <img src="https://img.shields.io/badge/lucide--react-FF5555?style=for-the-badge&logo=lucide&logoColor=white">
</div>

### 폼 및 데이터 유효성 검증

<div>
  <img src="https://img.shields.io/badge/React%20Form-61DAFB?style=for-the-badge&logo=react&logoColor=white">
  <img src="https://img.shields.io/badge/Zod-2D3748?style=for-the-badge&logo=typescript&logoColor=white">
</div>

### PWA

<div>
  <img src="https://img.shields.io/badge/PWA-FFD700?style=for-the-badge&logo=progressive-web-apps&logoColor=black">
</div>

### 도구

<div>
  <img src="https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white">
  <img src="https://img.shields.io/badge/Github-181717?style=for-the-badge&logo=Github&logoColor=white">
  <img src="https://img.shields.io/badge/Figma-F24E1E?style=for-the-badge&logo=Figma&logoColor=white">
</div>

### 기타 유틸리티

<div>
  <img src="https://img.shields.io/badge/fast--xml--parser-4F46B8?style=for-the-badge&logo=xml&logoColor=white">
  <img src="https://img.shields.io/badge/date--fns-5A67D8?style=for-the-badge&logo=javascript&logoColor=white">
</div>
<br /><br /><br />

## 디자인 컨셉

아기에게 필요한 예방접종 정보를 알려주는 서비스인 만큼 어린아이의 눈높이에 맞는 컨셉을 가지려 했습니다.

- 서비스명 '따꼼' : 어린아이에게 '아프다'라는 말 대신 '아야'하는거야 라고 말해주듯, 주사를 아이의 관점으로 '따꼼' 하는 것에서 착안해 서비스명을 '따꼼'으로 지었습니다.
- 마스코트 '따꼬미' : 주사를 맞으면 머리가 쭈뼛서고, 따끔한 것을 이미지화 하여 표현하였습니다.
- 직관적이고 심플한 UI : 생소할 수 있는 접종명, 백신명 등을 이해하기 쉽게 표시하고, 전반적인 서비스 이용이 어렵지 않도록 구성하였습니다.
  <br /><br /><br />

## 서비스 구조

- 메인 페이지
  - 연령별 접종 정보 페이지, 병원 찾기 페이지, 맞춤 예방점종 플랜 페이지 이동
  - 각종 이벤트 소개
- 연령별 예방접종 정보 페이지
  - 연령 선택
  - 연령에 따른 예방접종 필터
  - 해당 예방접종이 가능한 병원 검색
- 동네 병원 찾기 페이지
  - 병원 목록 불러오기
  - 병원 검색결과 필터
- 우리 아이 맞춤형 플랜 페이지
  - 사용자의 아이 기본 정보 등록 (이름, 생년월일, 특이사항, 아이 프로필 이미지)
  - 사용자의 아이 접종 내역 등록
  - 등록된 아이의 정보 수정
  - 등록된 정보를 바탕으로 맞춤형 접종 일정 월별 제공
  - 전체 접종 체크 리스트 확인 가능 (접종 기록 추가/삭제 가능)
- 회원가입/로그인 페이지
  - 인증/인가를 통한 회원가입 및 로그인 기능
  - 로그인 및 회원가입 시 유효성 검사
  - 소셜 로그인/회원가입 가능
- 마이페이지
  - 사용자 정보 확인
  - 로그아웃
    <br/><br/><br/>

## 와이어프레임

![1 홈페이지](https://github.com/user-attachments/assets/45258cdf-67b7-40c0-a2b2-db37bcf37213)
![2 접종 리스트](https://github.com/user-attachments/assets/38f38ade-805c-4098-a39c-08f789bcad3c)
![2 페이지 이동](https://github.com/user-attachments/assets/36640b0f-b22f-4106-8ecb-fcb0eb459585)
![3 병원검색페이지](https://github.com/user-attachments/assets/819e6b5b-c9d1-426a-b926-004fd667f9bc)
<br/><br/><br/>

## API 명세서

### 기본정보

- API 이름 : [질병관리청 어린이 국가예방접종 지원사업 위탁의료기관 현환 정보](https://www.data.go.kr/data/15084303/openapi.do?recommendDataYn=Y#/API%20%EB%AA%A9%EB%A1%9D/getOrgList3)
- 버전: 1.0.0
- Base URL: https://apis.data.go.kr/1790387/orglist3

### 인증

- 인증방식: 공공데이터포털에서 받은 인증키

### 메서드

- GET

### 엔드포인트

- GET /getOrgList3

  - 지역코드, 검색어를 기준으로 어린이 국가예방접종 지정의료기관 상세정보를 조회하는 의료기관 정보 조회 기능
  - 요청 파라미터:
    - serviceKey: 인증키
    - brtcCd: 시도 코드
    - sggCd: 시군구 코드
    - searchTpcd: 검색어 구분 코드(주소(ADDR) / 기관명(ORG))
    - searchWord: 검색어
    - numOfRows: 페이지당 표출 데이터 수
    - pageNo: 현재 페이지
  - 상태 코드: 200
    <details>
    <summary>응답 예시</summary>
    <div markdown="1">
      ```xml
      <response>
      <header>
        <resultCode>00</resultCode>
        <resultMsg>NORMAL SERVICE.</resultMsg>
      </header>
      <body>
        <dataTime>20241119070519460</dataTime>
        <pageNo>1</pageNo>
        <numOfRows>2</numOfRows>
        <totalCount>170</totalCount>
        <maxPage>85</maxPage>
        <items>
          <item>
            <orgcd>12348287</orgcd>
            <orgnm>(의)성광의료재단 차움의원</orgnm>
            <orgTlno>02-3015-5000</orgTlno>
            <orgAddr>서울특별시 강남구 도산대로 442, (청담동) 피엔폴루스 2층일부, 3층일부</orgAddr>
            <expnYmd>20240820</expnYmd>
            <vcnList>
              <vcnInfo>
                <vcnNm>사람유두종바이러스(HPV, 가다실)_자궁경부암</vcnNm>
                <vcncd>2001</vcncd>
              </vcnInfo>
            </vcnList>
          </item>
          <item>
            <orgcd>13312545</orgcd>
            <orgnm>365삼성의원</orgnm>
            <orgTlno>02-555-0365</orgTlno>
            <orgAddr>서울특별시 강남구 도곡로 331, (역삼동) 7층</orgAddr>
            <expnYmd>20240730</expnYmd>
            <vcnList>
              <vcnInfo>
                <vcnNm>인플루엔자(Flu)</vcnNm>
                <vcncd>0901</vcncd>
              </vcnInfo>
            </vcnList>
          </item>
        </items>
      </body>
      </response>
      ```
    </div>
    </details>

- GET /getCondBrtcCd3

  - 의료기관 조회 기준 목록(시도) 조회
  - 요청 파라미터:
    - serviceKey: 인증키
  - 상태 코드: 200
    <details>
    <summary>응답 예시</summary>
    <div markdown="1">
    ```xml
    <response>
    <header>
      <resultCode>00</resultCode>
      <resultMsg>NORMAL SERVICE.</resultMsg>
    </header>
    <body>
      <dataTime>20241119055641411</dataTime>
      <pageNo>1</pageNo>
      <numOfRows>17</numOfRows>
      <totalCount>17</totalCount>
      <items>
        <item>
          <cd>1100000000</cd>
          <cdNm>서울특별시</cdNm>
        </item>
        <item>
          <cd>2600000000</cd>
          <cdNm>부산광역시</cdNm>
        </item>
        ...
      </items>
    </body>
    </response>
    ```
    <div>
    </details>

- GET /getCondSggCd3

  - 의료기관 조회 기준 목록(시군구) 조회
  - 요청 파라미터:

    - serviceKey: 인증키
    - brtcCd: 시도 코드

  - 응답 코드: 200
    <details>
    <summary>응답 예시</summary>
    <div markdown="1">
    ```xml
    <response>
      <header>
        <resultCode>00</resultCode>
        <resultMsg>NORMAL SERVICE.</resultMsg>
      </header>
      <body>
        <dataTime>20241119070316188</dataTime>
        <pageNo>1</pageNo>
        <numOfRows>25</numOfRows>
        <totalCount>25</totalCount>
        <items>
          <item>
            <cd>11680</cd>
            <cdNm>강남구</cdNm>
          </item>
          <item>
            <cd>11740</cd>
            <cdNm>강동구</cdNm>
          </item>
          ...
        </items>
      </body>
      </response>
    ```
    </div>
    </details>

## 기능 설명

### [연령별 예방접종 정보]

1. 연령별 예방 접종 정보 필터 가능
   <br>- 대분류: 전체, 신생아, 영아기, 유아기, 아동기
   <br>- 중분류: 개월수, 나이
2. 해당 예방접종이 가능한 병원을 모달창을 통해 검색 후 병원찾기 페이지로 이동

### [동네 병원 찾기]

1. 시도(필수), 시군구(필수), 주소(선택), 병원명(선택) 입력 후 검색 가능

2. 특정 백신을 접종하는 병원을 찾을 수 있도록 백신 필터 기능 제공

3. 병원 정보 제공(주소, 전화번호, 접종 목록)

### [우리아이 맞춤형 플랜]

1. 사용자의 아이 등록 1단계: 이름(필수), 생년월일(필수), 특이사항(선택), 프로필 이미지(선택)
2. 사용자의 아이 등록 2단계: 접종 체크리스트를 통해 이미 맞은 접종을 체크
3. 아이 정보 등록/수정 기능
4. 접종 일정표를 통해 월별 접종 일정 확인

### [로그인/회원가입]

1. 일반 로그인: 아이디, 비밀번호
2. 소셜 로그인: 구글, 카카오톡
3. 인증/인가 및 유효성 검사

### [마이페이지]

1. 유저 정보 확인
2. 로그아웃 기능
   <br/><br/><br/>

## Trouble Shooting

### 1. 접종 정보 페이지: 페이지네이션 (이석원)

- 문제: 페이지네이션 적용한 정보 리스트에서 필터링 적용 시 최초 전체 로딩에서 설정된 페이지에 데이터가 고정되는 현상
- 문제 원인: 데이터 fetch시 supabase의 count를 통해 totalPage를 설정하면서 데이터 자체에 페이지가 적용되었으나, 데이터를 가져온 후 client에서 상태를 통한 필터링으로 생기는 문제
- 해결방법: client에서 데이터를 가공하여 출력하기 때문에 페이지네이션 또한 페이지 상태를 추가하여 가공한 데이터를 기반으로 작동하도록 수정함.

```tsx
// 선택된 연령에 따라 데이터 필터링
const filteredData = useMemo(() => {
  if (!allData) return [];
  return selectedAge === 1000
    ? allData
    : allData
        .filter((item) => JSON.parse(item.vaccinate_date || "[]").includes(selectedAge))
        .sort(
          (a, b) =>
            a.disease_name.localeCompare(b.disease_name) ||
            a.vaccine_name.localeCompare(b.vaccine_name) ||
            a.vaccine_turn.localeCompare(b.vaccine_turn)
        );
}, [allData, selectedAge]);

// 총 페이지 수 계산
const totalPages = Math.ceil(filteredData.length / ITEMS_PER_PAGE);
```

- 문제:
-

### 2. 동네 병원 찾기 (전해인)

- 문제상황: 검색창과 페이지네이션에 사용할 state를 너무 많이 설정해, React에서 오류가 발생
- 해결방법: 검색창에 입력된 정보를 모두 하나의 state로 합치고, 페이지네이션에 필요한 정보는 쿼리스트링으로 넘기게 되었습니다.

  - 이전에는 `brtcCd`, `sggCd`, `addr`, `org`에 대한 state가 별도로 존재했지만 현재는 `params`라는 이름의 state로 합쳤습니다.

  - 페이지내이션은 상위 컴포넌트에서 `currentPage`와 `startNum`을 저장해 state를 prop으로 넘겨주었지만, 데이터를 불러오는 과정과 렌더링되는 과정에서 오류와 경고가 발생해 쿼리스트링으로 불러오게 되었습니다. 쿼리스트링을 사용하니 한층 더 간결하게 페이지네이션을 구현할 수 있었습니다.

  ```tsx
  // 상위 컴포넌트
  const HospitalList = ({ searchParams, user }: HospitalListProps) => {
    const [params] = useQueryParams(new URLSearchParams(searchParams).toString());
    const [brtcCd, sggCd, addr, org, disease, currentPage] = [
      searchParams.get("brtcCd") ?? "",
      searchParams.get("sggCd") ?? "",
      searchParams.get("addr") ?? "",
      searchParams.get("org") ?? "",
      searchParams.get("disease") ?? "",
      Number(searchParams.get("pageNo")) ?? 1
    ];

    ...

    return (
      ...
          <HospitalPagination
            maxPage={hospitalData.maxPage}
            currentPage={currentPage}
            params={{ brtcCd, sggCd, addr, org, disease }}
          />
      ...
    );
  };

  export default HospitalList;
  ```

- 문제상황: 데스크탑에서 잘 되던 병원 카드의 접종 목록 클릭이 일관되지 않음.
- 해결방볍:

  - 병원카드를 나열할 때 사용한 li 태그에서 onClick 함수를 `data-select='true'`가 추가된 컴포넌트와 겹칠 시 이벤트가 실행되지 않도록 했습니다.

  ```tsx
  const HospitalList = ({ searchParams, user }: HospitalListProps) => {
    ...
    const handleClick = (e: React.MouseEvent<HTMLLIElement, MouseEvent>, info: HopsitalItem) => {
      if ((e.target instanceof HTMLElement || e.target instanceof SVGElement) && e.target.dataset.select) {
        // 모바일 클릭 오류 방지용: data-set='true' 달려있을 땐 동작하지 않음
        return;
      }
      setClickedId((prev) => {
        if (prev === info.orgcd) {
          return 0;
        }
        return info.orgcd;
      });
    }
    return (
      ...
              <li
                key={info.orgcd}
                onClick={(e) => {
                  e.stopPropagation();
                  handleClick(e, info);
                }}
              >
                ...
              </li>

      ...
    );
  };
  ```

- 문제상황: 검색어를 적용하거나 백신 찾기로 필터를 설정하면 페이지 로딩이 너무 길어짐.
- 해결방법
  - `useRouter()` 대신 History API를 사용해 SPA처럼 페이지 전환.
  - `use-query-param.ts`에 커스텀 훅을 만들어 페이지 상태 변화를 감지할 수 있도록 함.

### 3. 복잡한 라벨 로직을 컴포넌트 분리로 개선 (정지형)

- 문제 상황

  - 복잡한 라벨 표시 로직: VaccineRecordList 컴포넌트에서 각 질병의 diseaseName 앞에 라벨("선택" 또는 "필수")을 표시해야 했는데, 이는 diseaseName의 additions 값에 따라 결정됨
  - additions 값이 모두 true면 "선택", 하나라도 false면 "필수"로 라벨을 표시해야 함
  - 가독성 저하: VaccineRecordList 내에서 라벨 로직이 직접 작성되어 코드가 복잡하고 가독성이 떨어짐

  ```tsx
  {data?.map(({ vaccineName, disease }) =>
            disease.map(({ diseaseName, ids, additions }) => {
              const isRequiredNot = additions.every((addition) => addition);
              const label = isRequiredNot ? "선택" : "필수";
              return (
                <li key={vaccineName}>
                  <div>{diseaseName}</div>
                  <div>{vaccineName}</div>
                ...
  ```

- 해결 방법

  - VaccineLabel 컴포넌트 분리:

    - additions 값을 받아서 "선택" 또는 "필수" 라벨을 반환하는 VaccineLabel 컴포넌트를 생성.
    - additions 배열이 전부 true면 "선택", 그렇지 않으면 "필수"로 표시하도록 구현.

  - VaccineRecordList 내 로직 단순화:
    - VaccineLabel 컴포넌트를 사용하여 라벨 로직을 간결하게 분리, VaccineRecordList 컴포넌트의 가독성을 개선함.

  ```tsx
  const VaccineLabel = ({ additions }: { additions: boolean[] }) => {
    const isRequiredNot = additions.every((addition) => addition);
    if (isRequiredNot) return <div>선택</div>
    if (!isRequiredNot) return <div>필수</div>
  };
  ...
  {data?.map(({ vaccineName, disease }) =>
      disease.map(({ diseaseName, ids, additions }) => (
          <li key={vaccineName}>
              <VaccineLabel additions={additions} />
              <div>{diseaseName}</div>
              <div>{vaccineName}</div>
              ...
  ```

### 4. [아이 중복 등록 이슈 해결] 아이 정보 등록 중 발생한 409 Conflict 오류 (장세희)

- 문제 상황

  - 오류 메시지: duplicate key value violates unique constraint "child_pkey"
  - 다음 버튼을 클릭할 때마다 새로운 자녀 정보가 등록되어 중복된 데이터가 생성
  - 다음 버튼을 누를 때마다 childInfo가 초기화되거나 새로운 값으로 덮어쓰여, 이전 상태를 잃어버림, 결과적으로 이전 데이터를 재사용하지 못하고 새로운 데이터만 생성하고 있었음

- 해결 목표

  - 아이디가 중복된 경우 새 데이터를 삽입하지 않고 기존 데이터를 업데이트하도록 코드 수정

- 구현 방법

  - 중복된 데이터가 있으면 update로 기존 데이터를 수정
  - 중복 데이터가 없으면 insert로 새 데이터를 삽입

- 주요 개선점

  - 중복 등록 방지: 중복된 id로 새 레코드가 생성되지 않고 기존 데이터가 업데이트됨
  - 로직 안정성 강화: 비동기 작업에서 발생 가능한 오류를 체계적으로 처리

  ```tsx
  const handleComplete = async () => {
    try {
      if (!childInfo.id) {
        throw new Error("아이디가 없습니다. 유효한 아이디를 입력해 주세요.");
      }

      // 중복 데이터 확인
      const { data: existingData, error: selectError } = await browserClient
        .from("child")
        .select("*")
        .eq("id", childInfo.id)
        .single();

      if (selectError && selectError.code !== "PGRST116") {
        throw selectError;
      }

      if (existingData) {
        // 기존 데이터 업데이트
        const { error: updateError } = await browserClient
          .from("child")
          .update({ ...childInfo, user_id: userId })
          .eq("id", childInfo.id);

        if (updateError) {
          throw updateError;
        }
      } else {
        // 새 데이터 삽입
        const { error: insertError } = await browserClient.from("child").insert([{ ...childInfo, user_id: userId }]);

        if (insertError) {
          throw insertError;
        }
      }
    } catch (error) {
      console.error("아이 등록 중 오류 발생:", error);
    }
  };
  ```

### 5. 이전 단계로 돌아갈 때 작성된 Form 데이터를 유지가 안됨 (장세희)

- 문제 상황
  - 이전 단계 데이터 유실: 이전 버튼을 통해 1단계로 돌아가면 이전에 입력한 Form 데이터가 불러와지지 않음.
  - 데이터는 이미 저장됨: supabase의 child 테이블에는 데이터가 저장된 상태이나, UI에서 다시 돌아갔을 때 저장된 정보가 표시되지 않음.
- 해결 방법

  - RegisterForm에서 childInfo 상태 생성

    - RegisterForm 컴포넌트에서 childInfo를 상태로 생성하여, 기본값으로 빈 객체({})로 초기화
    - childInfo를 RegisterChildInfo에 props로 전달하여, 이전 단계에서 입력한 정보가 유지되도록 함

  - RegisterChildInfo에서 childInfo 활용 - RegisterChildInfo 컴포넌트에서 전달받은 childInfo의 데이터를 Form의 defaultValues로 설정하여, 초기 값으로 사용. - 이렇게 설정하면 이전 버튼을 통해 돌아올 때 이전에 입력한 정보가 자동으로 입력란에 표시됨.

    ```tsx
    const RegisterForm: React.FC<ChildCardProps> = ({ userId }) => {
      const [childInfo, setChildInfo] = useState<Partial<Child>>({});

      return <RegisterChildInfo onNext={handleNext} userId={userId} childInfo={childInfo} />;
    };
    ```

    ```tsx
    const RegisterChildInfo = ({ onNext, userId, childInfo }: RegisterChildInfoProps) => {
      const form = useForm({
        resolver: zodResolver(formSchema),
        defaultValues: {
          name: childInfo.name || "",
          birth: childInfo.birth || "",
          notes: childInfo.notes || ""
        }
      });

      return <div>{/* JSX 코드 */}</div>;
    };
    ```

### 6. 소셜 로그인 리다이렉트 오류 (이예람)

- 문제 상황
  - 소셜 로그인 기능을 구현하는 과정에서, 사용자가 소셜 로그인 후 다시 페이지로 돌아올 때 리다이렉트 설정이 제대로 되어있지 않아 오류가 발생
  - 리다이렉트 URL 설정을 redirectTo를 통해 하였으나, 배포 환경에서는 각 환경에 맞는 리다이렉트 URL이 제대로 설정되지 않아 문제가 발생
- 해결 방법

  - 리다이렉트 URL 설정: redirectTo를 사용하여 로그인 후 리다이렉트할 URL을 설정
  - 환경 변수 사용: 배포 환경에서 리다이렉트 URL을 환경 변수로 설정하여 NEXT_PUBLIC_GOOGLE_REDIRECT_URL 값을 통해 vercel과 supabase에서 각 환경에 맞는 리다이렉트 URL을 자동으로 설정

  ```tsx
  const googleSignIn = async () => {
    const { error } = await browserClient.auth.signInWithOAuth({
      provider: "google",
      options: {
        queryParams: {
          access_type: "offline",
          prompt: "consent"
        },
        redirectTo: process.env.NEXT_PUBLIC_GOOGLE_REDIRECT_URL // 환경
      }
    });

    if (error) console.log("로그인 실패 : ", error);
  };
  ```

  <br /><br /><br />

## 자랑하고 싶은 코드

### [연령별 예방 접종 정보] (이석원)

- 데이터 필터링을 위한 분류별 연결을 위한 전역상태관리
- 대분류에 따른 소분류 변동과 병명 초기화 작동

  ```tsx
  // 연령별 예방 접종 데이터 필터링
  // 'ageGroup'을 기준으로 'subAgeGroup'과 'selectedAge'를 업데이트하고,
  // 'currentDisease'는 초기화합니다.
  setAgeGroup: (newText: string) =>
      set(() => {
        return {
          ageGroup: newText,
          subAgeGroup: subGroup[newText],   // 대분류에 따른 소분류 데이터 설정
          selectedAge: subGroup[newText][0], // 첫 번째 연령 선택
          currentDisease: "" // 병명 초기화
        };
      }),

  const subGroup: { [key: string]: number[] } = {
    전체: [1000],
    신생아: [0, 0.4],
    영아기: [1, 2, 4, 6],
    유아기: [12, 15, 18, 19, 24, 48],
    아동기: [72, 132, 144]
  };
  ```

- 성능 향상을 위한 메모이제이션 적용
- 의존성 배열 설정을 통해 불필요한 리렌더링을 방지해보고자 함

  ```tsx
  // 선택된 연령에 따라 데이터 필터링
  const filteredData = useMemo(() => {
    if (!allData) return [];
    return selectedAge === 1000
      ? allData
      : allData.filter((item) => JSON.parse(item.vaccinate_date || "[]").includes(selectedAge));
  }, [allData, selectedAge]);

  // 총 페이지 수 계산
  const totalPages = Math.ceil(filteredData.length / ITEMS_PER_PAGE);

  // 현재 페이지에 해당하는 데이터 계산
  const currentPageData = useMemo(() => {
    const startIndex = (page - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    return filteredData.slice(startIndex, endIndex);
  }, [filteredData, page]);

  // 페이지가 유효 범위를 벗어나면 첫 페이지로 리셋
  useMemo(() => {
    if (page > totalPages) {
      setPage(1);
    }
  }, [totalPages, page]);
  ```

### [동네 병원 찾기] (조해인)

1. 병원 정보 데이터 가져오는 방법 개선

- '어린이 국가예방접종 지원사업 위탁의료기관 현황 정보' api를 사용하여 해당 지원사업을 진행중인 병원 정보를 가져왔습니다. 공공데이터로 api 구조를 원하는대로 바꿀 수 없어 지원하는 기능을 사용하여 모든 병원 정보를 불러온 후 추가로 필터링을 거쳐 데이터를 나열했습니다.

- 아래 코드는 첫 100개의 데이터를 불러와 추가 데이터가 있는지 확인한 후 `Promise.all`을 사용해 남은 데이터를 불러와 합쳐주는 코드입니다. Api에서 '시도, 시군구', '시도, 시군구, 주소' 또는 '시도, 시군구, 병원명' 검색까지만 지원해, 저희가 제공하려는 서비스보다 기능이 부족해 위 과정을 거치게 되었습니다. 이후 `useQuery` 커스텀 훅을 통해 데이터를 캐싱하여 불필요한 요청을 하지 않도록 했습니다. 자주 변동되는 데이터는 아니지만 업데이트 될 수 있으므로 1시간마다 `revalidate`하도록 했습니다.

  ```tsx
  // 병원 목록 가져오기
  export const getHospitals = async (
    input: HospitalParams
  ): Promise<HospitalData> => {
    const params = { serviceKey, ...input, numOfRows: "100", pageNo: "1" };
    ...
    const res = await fetch( ... , {
      method: "GET",
      next: {
        revalidate: 3600
      }
    });

    ...

    if (body.maxPage > 1) {
      const allData = await Promise.all(
        Array(body.maxPage - 1)
          .fill(0)
          .map(async (_, idx) => {
            ...
            const res = await fetch( ... , {...});
            ...
          })
      );
      ...
    }

    ...
  };
  ```

2. 페이지 로딩 개선

- Next.js 14 App Router의 `router.push()`를 사용하니 페이지 로딩이 너무 길어지는 문제점이 있었습니다. 이를 트러블 슈팅에서 이야기한 것처럼 아래와 같은 커스텀 훅을 만들어 페이지 로딩 시간을 단축할 수 있었습니다.

- `setQueryParams` 함수는 History API를 사용해 url을 변경해주는 함수입니다. `SearchForm.tsx`에서 검색 버튼을 누르면 커스텀 훅에 input으로 넣는 값의 state를 변경해, 연관된 `HospitalList.tsx`에서도 변경된 검색어들을 객체로 받을 수 있도록 했습니다.

  ```tsx
  const useQueryParams = (currentQuery: string): [HospitalSearchParams, (params: HospitalSearchParams) => void] => {
    const [params, setParams] = useState<HospitalSearchParams>(Object.fromEntries(new URLSearchParams(currentQuery)));

    useEffect(() => {
      // 클라이언트 환경에서만 실행됨
      if (typeof window === "undefined") {
        return;
      }

      const handlePopState = () => {
        // 뒤로 가기 또는 앞으로 가기 시 (= url 변경 시 발생) 쿼리 파라미터 업데이트
        setParams(Object.fromEntries(new URLSearchParams(window.location.search)));
      };

      // 처음 마운트될 때 실행
      handlePopState();

      // popstate 이벤트 리스너 추가
      window.addEventListener("popstate", handlePopState);

      // 언마운트될 때 이벤트 리스너 제거
      return () => {
        window.removeEventListener("popstate", handlePopState);
      };
    }, [currentQuery]);

    const setQueryParams = (params: HospitalSearchParams) => {
      const newUrl = createQueryParams(params, "/hospital");
      window.history.pushState({ ...window.history.state, as: newUrl, url: newUrl }, "", newUrl);
      window.dispatchEvent(new PopStateEvent("popstate"));
    };

    return [params, setQueryParams];
  };
  ```

### [우리 아이 맞춤형 플랜] (장세희)

1. <b>Custom Hooks 활용 (useChildrenQuery, useUserQuery)</b>

- useChildrenQuery, useUserQuery라는 custom hooks으로 분리하여 코드의 재사용성을 높이고, 각 데이터 fetch 로직을 더 직관적으로 만들었습니다. 이 방식은 코드의 유지보수를 쉽게 하고, 추후 다른 페이지에서도 재사용 가능이 가능합니다. Custom hook을 통한 코드 분리는 다른 개발자들이 코드를 빠르게 이해할 수 있게 하며, 이로 인해 협업에서도 유리한 점이 많습니다.

2. <b>접종 관리에서의 필수 및 선택 접종 상태를 구분하고 계산하는 로직</b>

- 따꼼 프로젝트에서 ChildCard 컴포넌트는 아이의 필수 및 선택 접종 상태를 직관적으로 확인할 수 있도록 돕는 중요한 역할을 합니다. 이 컴포넌트의 한가지 기능은 접종 데이터를 분석하여, 필수 접종과 선택 접종의 전체 개수와 완료된 개수를 정확히 계산하는 것입니다.

- <b>이 코드가 특별한 이유!</b>

  - <b>복잡한 데이터 구조를 정교하게 처리</b>: 접종 데이터는 disease, ids, additions 등의 중첩된 배열로 이루어져 있어 처리하기 까다롭습니다. 이 코드는 각 접종 항목을 순회하며, 필수/선택 접종 여부를 정확히 판별하고 개별 접종 기록과 대조하여 결과를 도출합니다.
  - <b>직관적인 결과 제공</b>: 코드의 결과는 필수 접종 3/18개, 선택 접종 1/16개처럼 현재 상태를 직관적으로 보여줍니다. 이는 사용자에게 접종 상황을 한눈에 파악할 수 있도록 도움을 줍니다.
  - <b>문제 해결을 위한 발전</b>: 초기에는 disease.additions와 disease.ids의 길이가 다를 때 잘못된 결과를 반환하는 문제가 있었습니다. 이 코드는 각 ID마다 개별적으로 처리하도록 수정되어, 데이터를 정확히 처리하는 데 성공했습니다.

  ```tsx
  const getVaccinesCount = () => {
    let requiredVaccinesCount = 0; // 맞은 필수 접종 수
    let optionalVaccinesCount = 0; // 맞은 선택 접종 수
    let totalRequiredVaccines = 0; // 전체 필수 접종 수
    let totalOptionalVaccines = 0; // 전체 선택 접종 수

    vaccineData.forEach((vaccine) => {
      vaccine.disease.forEach((disease) => {
        disease.ids.forEach((id, index) => {
          const isOptional = disease.additions[index];
          const allCheckedVaccine = vaccineRecord.includes(id);

          if (isOptional) {
            totalOptionalVaccines++;
            if (allCheckedVaccine) optionalVaccinesCount++;
          } else {
            totalRequiredVaccines++;
            if (allCheckedVaccine) requiredVaccinesCount++;
          }
        });
      });
    });

    return { requiredVaccinesCount, totalRequiredVaccines, optionalVaccinesCount, totalOptionalVaccines };
  };
  ```

3. <b>자녀 정보 입력과 유효성 검사 (RegisterChildInfo)</b>

- formSchema는 zod를 사용하여 이름과 생년월일을 필수로 설정하며, 추가로 메모와 프로필 이미지는 선택 사항입니다.
- useForm에서 zodResolver를 사용해 쉽게 유효성 검사를 설정하고, form.handleSubmit을 통해 제출 시 검사를 실행합니다.

  ```tsx
  import { useForm } from "react-hook-form";
  import { z } from "zod";
  import { zodResolver } from "@hookform/resolvers/zod";

  export const formSchema = z.object({
    name: z.string().min(1, { message: "이름은 필수입니다." }),
    birth: z.string().min(1, { message: "생년월일은 필수입니다." }),
    notes: z.string().optional(),
    profileImage: z.instanceof(File).optional()
  });

  const RegisterChildInfo = ({ onNext, childInfo }) => {
    const form = useForm<z.infer<typeof formSchema>>({
      resolver: zodResolver(formSchema),
      defaultValues: {
        name: childInfo.name ?? "",
        birth: childInfo.birth ?? "",
        notes: childInfo.notes ?? ""
      }
    });

    const handleFormSubmit = async (data) => {
      onNext(data);
    };

    return (
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8 w-full">
          {/* 프로필 이미지 입력 필드 */}
          <FormField
            control={form.control}
            name="profileImage"
            render={() => (
              <FormItem>
                <FormLabel>프로필 이미지</FormLabel>
                <FormControl>
                  <Input
                    type="file"
                    accept="image/*"
                    onChange={(e) => setSelectedImage(e.target.files?.[0] ?? undefined)}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          {/* 이름 입력 필드 */}
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel>이름</FormLabel>
                <FormControl>
                  <Input placeholder="ex. 김따꼼" {...field} className="w-full" />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <Button type="submit">다음</Button>
        </form>
      </Form>
    );
  };
  ```

### [우리 아이 맞춤형 플랜 - 접종 체크리스트] (정지형)

1. 데이터 그룹화

- Map 자료구조를 통하여 데이터를 백신이름과 질병별로 그룹화
- 중복되는 백신이름을 통합하여 각 백신의 질병이름과 접종차수, id, 추가정보를 담고 있는 객체 배열로 반환

  ```tsx
  export const groupVaccines = (vaccines: Vaccine[]) => {
    const vaccineMap = new Map<string, Map<string, { turns: number[]; ids: string[]; additions: boolean[] }>>();
    vaccines.forEach((vaccine) => {
      const { disease_name, vaccine_turn, id, vaccine_name, additional } = vaccine;
      if (!disease_name || !vaccine_turn || !vaccine_name) return;
      if (!vaccineMap.has(vaccine_name)) {
        vaccineMap.set(vaccine_name, new Map());
      }
      const diseaseMap = vaccineMap.get(vaccine_name);
      if (!diseaseMap?.has(disease_name)) {
        diseaseMap?.set(disease_name, { turns: [], ids: [], additions: [] });
      }
      diseaseMap?.get(disease_name)?.turns.push(vaccine_turn);
      diseaseMap?.get(disease_name)?.ids.push(id);
      diseaseMap?.get(disease_name)?.additions.push(additional);
    });
    const vaccinesArray = Array.from(vaccineMap.entries()).map(([vaccineName, diseaseMap]) => ({
      vaccineName,
      disease: Array.from(diseaseMap.entries()).map(([diseaseName, data]) => ({
        diseaseName,
        turns: data.turns,
        ids: data.ids,
        additions: data.additions
      }))
    }));
    return vaccinesArray;
  };
  ```

2. 접종 일정표

- supabase에 저장한 접종 일정표를 기준으로 아이 생일에 맞는 접종 일정표를 제공합니다. 접종이 완료된 경우 목록에서 제거되며 선택, 해당 백신을 접종해야 하는 날짜와 추가/필수 접종 여부를 제공합니다.

- 접종 일정표를 계산하는 핵심 로직은 다음과 같습니다. 각 접종 일정에 포함된 달에 해당 접종 일정을 저장해 월별 접종 일정표를 반환해줍니다. `date-fns` 라이브러리를 사용하여 날짜 계산을 효율적으로 처리할 수 있었습니다.

  ```tsx
  // 생일에 따라 접종 일정 계산하기
  export const calculateSchedule = (
    date?: string,
    schedules?: Tables<"vaccine">[]
  ): Map<string, vaccineSchedule[]> | null => {
    if (!date || !schedules) {
      return null;
    }
    const birthday = new Date(date);
    const mySchedule = new Map();
    // 접종일정표 상 가장 나중 일정의 마지막 일자
    const lastMonth = addDays(addMonths(addMonths(birthday, 12 * 12), 12), -1);

    // 비어 있는 달이 존재할 수 이어서 key를 먼저 생성
    let currentDate = birthday;
    while (isBefore(currentDate, lastMonth) || isEqual(addDays(currentDate, -1), lastMonth)) {
      mySchedule.set(format(currentDate, "yyyy.MM"), []);
      currentDate = addMonths(currentDate, 1);
    }

    for (const schedule of schedules) {
      const { id, vaccine_name, disease_name, vaccinate_date, duration, additional, vaccine_turn } = schedule;
      const [after, unit] = duration.split(" ");
      const startDate = addMonths(birthday, vaccinate_date);
      const startDateFormatted = format(startDate, "yyyy.MM.dd");

      if (unit === "일") {
        // 일 단위
        const startDate = addMonths(birthday, vaccinate_date);
        const startDateFormatted = format(startDate, "yyyy.MM.dd");
        const startMonthFormatted = format(startDate, "yyyy.MM");
        mySchedule.set(
          startMonthFormatted,
          mySchedule.get(startMonthFormatted).concat([...])
        );
      } else {
        // 개월 단위
        const endDate = addDays(addMonths(addMonths(birthday, vaccinate_date), Number(after)), -1);
        const endDateFormatted = format(endDate, "yyyy.MM.dd");

        // 위에서 key를 생성한 로직과 동일
        // 일정이 시작하는 달부터 끝나는 달까지 해당 접종 일정을 추가함
        let currentDate = startDate;
        while (isBefore(currentDate, endDate) || isEqual(addDays(currentDate, -1), endDate)) {
          const currentMonthFormatted = format(currentDate, "yyyy.MM");
          mySchedule.set(
            currentMonthFormatted,
            mySchedule.get(currentMonthFormatted).concat([...])
          );
          currentDate = addMonths(currentDate, 1);
        }
      }
    }

    return mySchedule;
  };
  ```

### [회원가입-유효성검사] (이예람)

- zod를 이용해 복잡한 schema를 설정하였고, superRefine 매서드를 이용해 강력한 유효성 검사를 시도한 부분입니다.
- superRefine 매서드의 첫 번째 인자는 콜백함수가, 두 번째 인자에는 이슈를 생성하는 ctx가 들어갑니다. 이때, ctx에는 기존에 zod에서 제공하는 이슈도 있지만, 개발자가 직접 커스텀 할 수 있는 기능이 있어 해당 기능을 사용해 우리에게 맞는 이슈를 생성하였습니다.

  ```tsx
  const schema = z
    .object({
      email: z
        .string()
        .min(5, { message: "5글자 이상 입력해주세요." })
        .max(30, { message: "30글자 이하로 입력해주세요." }),
      password: z
        .string()
        .min(8, { message: "8글자 이상 입력해주세요." })
        .max(16, { message: "16글자 이하로 입력해주세요." }),
      passwordCheck: z
        .string()
        .min(8, { message: "8글자 이상 입력해주세요." })
        .max(16, { message: "16글자 이하로 입력해주세요." }),
      name: z.string().min(1, { message: "이름을 입력해주세요." })
    })
    .superRefine(({ password, passwordCheck }, ctx) => {
      // 비밀번호 재확인 체크
      if (password !== passwordCheck) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "비밀번호가 일치하지 않습니다.",
          path: ["passwordCheck"]
        });
      }
    });
  ```

  <br /><br /><br />

## 프로젝트 소감

<img width="691" alt="Screenshot 2024-11-06 at 8 31 36 PM" src="https://github.com/user-attachments/assets/86d45e55-5e9a-479a-a77d-49a9724a0e62">

- 이석원

  - 단순히 실습해보는 프로젝트가 아닌 실제 서비스 하기위한 프로젝트 결과물을 목표로 해보니 신경을 써야하는 부분이 더 많아졌습니다. 디자이너와 협업 그리고 사용자 테스트로 피드백 반영까지 많은 과정을 경험할 수 있었고, 협업 능력과 기술적 성장을 동시에 할 수 있던 시간이 되었습니다. 좋은 결과물이 나와 뿌듯합니다. 모두 고생 많으셨습니다.

- 조해인

  - 따꼼 프로젝트를 진행하며 실제 서비스 처럼 제공하기 위해 많이 노력했습니다. 사용자 테스트를 받아보니 저희가 생각하지 못한 부분에 대해 많이 말씀을 해주셔서 좀 더 생각의 폭을 넓힐 수 있었습니다. 또한 이전에는 데스크탑 환경만 고려했는데, 모바일 환경도 고려하게 되면서 PC환경에서 없던 클릭 이벤트 중첩 문제처럼 약간의 차이점을 느낄 수 있었습니다. 동네 병원 찾기 페이지에서 검색 버튼을 누르면 로딩이 길다는 피드백이 많았는데, 페이지 로딩 시간을 단축하기 위해 노력하며 한층 성장했다고 느꼈습니다.

    다들 한달 동안 고생하셨습니다. 감사합니다!

- 이예람

  - 실제 서비스까지 이어지는 경험은 정말 어려웠고 색다르기도하고 흥미로웠습니다! 무엇 하나 쉬운게 없었지만 팀장님과 팀원분들이 많이 도와주셔서 끝까지 포기하지 않고 끝마칠 수 있었던것같습니다. 마지막까지 문제도 많고 난항도 수 차례 겪었지만 사람들이 실제로 우리 서비스를 이용하는것을 직접 보고 피드백을 받으면서 너무 설레고 기쁘고 재미있기도 했습니다. 많이 부족한 저를 지금까지 이끌어주신 팀원분들께 진심으로 감사드립니다! 고생하셨습니다!

- 장세희

  - 소감소감

- 정지형

  - 소감소감

- 전수빈
  - 소감소감
